<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>MPSNNConcatenationNode Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">MacOSX 10.13 MetalPerformanceShaders Framework </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">Apple Inc.</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	

	
	<optgroup label="Class Methods">
		
		<option value="//api/name/nodeWithSources:">+ nodeWithSources:</option>
		
	</optgroup>
	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/initWithSources:">- initWithSources:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">MPSNNConcatenationNode Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td><a href="../Classes/MPSNNFilterNode.html">MPSNNFilterNode</a> : NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>MPSNNGraphNodes.h</td>
</tr>
						</tbody></table></div>
					

                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>Node representing a the concatenation (in the feature channel dimension) of the results from one or more kernels</p>
					</div>
					
					

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/nodeWithSources:" title="nodeWithSources:"></a>
	<h3 class="method-title"><code><a href="#//api/name/nodeWithSources:">+&nbsp;nodeWithSources:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Init a autoreleased node that concatenates feature channels from multiple images</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (nonnull instancetype)nodeWithSources:(NSArray&lt;MPSNNImageNode*&gt; *__nonnull)<em>sourceNodes</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>sourceNodes</code></th>
						<td><p>The <a href="../Classes/MPSNNImageNode.html">MPSNNImageNode</a> representing the source MPSImages for the filter</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A new MPSNNFilter node that concatenates its inputs.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>In some neural network designs, it is necessary to append feature channels
from one neural network filter to the results of another. If we have three
image nodes with M, N and O feature channels in them, passed to -initWithSources:
as @[imageM, imageN, imageO], then feature channels [0,M-1] will be drawn from
image M,  feature channels [M, M+N-1] will be drawn from image N and feature channels
[M+N, M+N+O-1] will be drawn from image O.</p>

<p>As all images are padded out to a multiple of four feature channels,
M, N and O here are also multiples of four, even when the MPSImages
are not. That is, if the image is 23 feature channels and one channel
of padding, it takes up 24 feature channels worth of space in the
concatenated result.</p>

<p>Performance Note:  Generally, concatenation is free as long as all
of the sourceNodes are produced by filters in the same <a href="../Classes/MPSNNGraph.html">MPSNNGraph</a>.
Most MPSCNNKernels have the ability to write their results  at a
feature channel offset within a target <a href="../Classes/MPSImage.html">MPSImage</a>. However, if the
<a href="../Classes/MPSNNImageNode.html">MPSNNImageNode</a> source nodes come from images external to the <a href="../Classes/MPSNNGraph.html">MPSNNGraph</a>,
then we have to do a copy operation to assemble the concatenated node.
As a result, when deciding where to break a large logical graph into
multiple smaller MPSNNGraphs, it is better for concatenations to
appear at the ends of subgraphs when possible rather than at the start,
to the extent that all the images used in the concatenation are
produced by that subgraph.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSNNGraphNodes.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithSources:" title="initWithSources:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithSources:">&ndash;&nbsp;initWithSources:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Init a node that concatenates feature channels from multiple images</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nonnull instancetype)initWithSources:(NSArray&lt;MPSNNImageNode*&gt; *__nonnull)<em>sourceNodes</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>sourceNodes</code></th>
						<td><p>The <a href="../Classes/MPSNNImageNode.html">MPSNNImageNode</a> representing the source MPSImages for the filter</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A new MPSNNFilter node that concatenates its inputs.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>In some neural network designs, it is necessary to append feature channels
from one neural network filter to the results of another. If we have three
image nodes with M, N and O feature channels in them, passed to -initWithSources:
as @[imageM, imageN, imageO], then feature channels [0,M-1] will be drawn from
image M,  feature channels [M, M+N-1] will be drawn from image N and feature channels
[M+N, M+N+O-1] will be drawn from image O.</p>

<p>As all images are padded out to a multiple of four feature channels,
M, N and O here are also multiples of four, even when the MPSImages
are not. That is, if the image is 23 feature channels and one channel
of padding, it takes up 24 feature channels worth of space in the
concatenated result.</p>

<p>Performance Note:  Generally, concatenation is free as long as all
of the sourceNodes are produced by filters in the same <a href="../Classes/MPSNNGraph.html">MPSNNGraph</a>.
Most MPSCNNKernels have the ability to write their results  at a
feature channel offset within a target <a href="../Classes/MPSImage.html">MPSImage</a>. However, if the
<a href="../Classes/MPSNNImageNode.html">MPSNNImageNode</a> source nodes come from images external to the <a href="../Classes/MPSNNGraph.html">MPSNNGraph</a>,
then we have to do a copy operation to assemble the concatenated node.
As a result, when deciding where to break a large logical graph into
multiple smaller MPSNNGraphs, it is better for concatenations to
appear at the ends of subgraphs when possible rather than at the start,
to the extent that all the images used in the concatenation are
produced by that subgraph.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSNNGraphNodes.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved. Updated: 2018-03-06</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>