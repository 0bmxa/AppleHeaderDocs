<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>MPSRNNMatrixInferenceLayer Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">MacOSX 10.13 MetalPerformanceShaders Framework </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">Apple Inc.</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	
	<optgroup label="Properties">
		
		<option value="//api/name/bidirectionalCombineMode">bidirectionalCombineMode</option>
		
		<option value="//api/name/inputFeatureChannels">inputFeatureChannels</option>
		
		<option value="//api/name/numberOfLayers">numberOfLayers</option>
		
		<option value="//api/name/outputFeatureChannels">outputFeatureChannels</option>
		
		<option value="//api/name/recurrentOutputIsTemporary">recurrentOutputIsTemporary</option>
		
		<option value="//api/name/storeAllIntermediateStates">storeAllIntermediateStates</option>
		
	</optgroup>
	

	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/copyWithZone:device:">- copyWithZone:device:</option>
		
		<option value="//api/name/encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:">- encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:</option>
		
		<option value="//api/name/encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:">- encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:</option>
		
		<option value="//api/name/initWithCoder:device:">- initWithCoder:device:</option>
		
		<option value="//api/name/initWithDevice:">- initWithDevice:</option>
		
		<option value="//api/name/initWithDevice:rnnDescriptor:">- initWithDevice:rnnDescriptor:</option>
		
		<option value="//api/name/initWithDevice:rnnDescriptors:">- initWithDevice:rnnDescriptors:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">MPSRNNMatrixInferenceLayer Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td><a href="../Classes/MPSKernel.html">MPSKernel</a> : NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>MPSRNNLayer.h</td>
</tr>
						</tbody></table></div>
					

                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>@class      MPSRNNMatrixInferenceLayer
@dependency This depends on Metal.framework</p><p>The MPSRNNMatrixInferenceLayer specifies a recurrent neural network layer for inference on MPSMatrices.
Currently two types of recurrent layers are supported: ones that operate with convolutions on
images: @ref <a href="../Classes/MPSRNNImageInferenceLayer.html">MPSRNNImageInferenceLayer</a> and one that operates on matrices: @ref MPSRNNMatrixInferenceLayer.
The former can be often used to implement the latter by using 1x1-matrices, but due to
image size restrictions and performance, it is advisable to use @ref MPSRNNMatrixInferenceLayer for
linear recurrent layers.
A MPSRNNMatrixInferenceLayer is initialized using a @ref MPSRNNLayerDescriptor, which further specifies the
recurrent network layer, or an array of @ref MPSRNNLayerDescriptors, which specifies a stack
of recurrent layers, that can operate in parallel a subset of the inputs in a sequence of inputs and
recurrent outputs. Note that currently stacks with bidirectionally traversing encode functions do not support starting
from a previous set of recurrent states, but this can be achieved quite easily by defining two separate
unidirectional stacks of layers, and running the same input sequence on them separately (one forwards and one backwards)
and ultimately combining the two result sequences as desired with auxiliary functions.
The input and output vectors in encode calls are stored as rows of the input and output matrices and currently
MPSRNNMatrixInferenceLayer supports only matrices with number of rows equal to one. The mathematical operation then is
strictly speaking y<sup>T</sup> = W x<sup>T</sup>  &lt;=> y = x W<sup>T</sup> in the linear transformations of @ref <a href="../Classes/MPSRNNSingleGateDescriptor.html">MPSRNNSingleGateDescriptor</a>,
@ref <a href="../Classes/MPSLSTMDescriptor.html">MPSLSTMDescriptor</a> and @ref <a href="../Classes/MPSGRUDescriptor.html">MPSGRUDescriptor</a>.</p>
					</div>
					
					

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/inputFeatureChannels" title="inputFeatureChannels"></a>
	<h3 class="method-title"><code><a href="#//api/name/inputFeatureChannels">&nbsp;&nbsp;inputFeatureChannels</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The number of feature channels input vector/matrix.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readonly, nonatomic) NSUInteger inputFeatureChannels</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   inputFeatureChannels</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/outputFeatureChannels" title="outputFeatureChannels"></a>
	<h3 class="method-title"><code><a href="#//api/name/outputFeatureChannels">&nbsp;&nbsp;outputFeatureChannels</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>The number of feature channels in the output vector/matrix.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readonly, nonatomic) NSUInteger outputFeatureChannels</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   outputFeatureChannels</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/numberOfLayers" title="numberOfLayers"></a>
	<h3 class="method-title"><code><a href="#//api/name/numberOfLayers">&nbsp;&nbsp;numberOfLayers</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Number of layers in the filter-stack. This will be one when using initWithDevice:rnnDescriptor to initialize
this filter and the number of entries in the array &lsquo;rnnDescriptors&rsquo; when initializing this filter with
initWithDevice:rnnDescriptors.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readonly, nonatomic) NSUInteger numberOfLayers</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   numberOfLayers</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/recurrentOutputIsTemporary" title="recurrentOutputIsTemporary"></a>
	<h3 class="method-title"><code><a href="#//api/name/recurrentOutputIsTemporary">&nbsp;&nbsp;recurrentOutputIsTemporary</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>How output states from @ref encodeSequenceToCommandBuffer are constructed.
Defaults to NO. For reference @see <a href="../Classes/MPSState.html">MPSState</a>.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readwrite, nonatomic) BOOL recurrentOutputIsTemporary</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   recurrentOutputIsTemporary</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/storeAllIntermediateStates" title="storeAllIntermediateStates"></a>
	<h3 class="method-title"><code><a href="#//api/name/storeAllIntermediateStates">&nbsp;&nbsp;storeAllIntermediateStates</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>If YES then calls to @ref encodeSequenceToCommandBuffer return every recurrent state
in the array: recurrentOutputStates.
Defaults to NO.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readwrite, nonatomic) BOOL storeAllIntermediateStates</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   storeAllIntermediateStates</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/bidirectionalCombineMode" title="bidirectionalCombineMode"></a>
	<h3 class="method-title"><code><a href="#//api/name/bidirectionalCombineMode">&nbsp;&nbsp;bidirectionalCombineMode</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Defines how to combine the output-results, when encoding bidirectional layers using
@ref encodeBidirectionalSequenceToCommandBuffer.
Defaults to @ref MPSRNNBidirectionalCombineModeNone.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (readwrite, nonatomic) MPSRNNBidirectionalCombineMode bidirectionalCombineMode</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property   bidirectionalCombineMode</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithDevice:rnnDescriptor:" title="initWithDevice:rnnDescriptor:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithDevice:rnnDescriptor:">&ndash;&nbsp;initWithDevice:rnnDescriptor:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Initializes a linear (fully connected) RNN kernel</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nonnull instancetype)initWithDevice:(nonnull id&lt;MTLDevice&gt;)<em>device</em> rnnDescriptor:(nonnull const MPSRNNDescriptor *)<em>rnnDescriptor</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>device</code></th>
						<td><p>The MTLDevice on which this MPSRNNMatrixLayer filter will be used</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>rnnDescriptor</code></th>
						<td><p>The descriptor that defines the RNN layer</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A valid MPSRNNMatrixInferenceLayer object or nil, if failure.</p>
			</div>
			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithDevice:rnnDescriptors:" title="initWithDevice:rnnDescriptors:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithDevice:rnnDescriptors:">&ndash;&nbsp;initWithDevice:rnnDescriptors:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Initializes a kernel that implements a stack of linear (fully connected) RNN layers</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nonnull instancetype)initWithDevice:(nonnull id&lt;MTLDevice&gt;)<em>device</em> rnnDescriptors:(NSArray&lt;constMPSRNNDescriptor*&gt; *__nonnull)<em>rnnDescriptors</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>device</code></th>
						<td><p>The MTLDevice on which this MPSRNNMatrixLayer filter will be used</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>rnnDescriptors</code></th>
						<td><p>An array of RNN descriptors that defines a stack of RNN layers, starting at index zero.
The number of layers in stack is the number of entries in the array.
All entries in the array must be valid MPSRNNDescriptors.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A valid MPSRNNMatrixInferenceLayer object or nil, if failure.</p>
			</div>
			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithDevice:" title="initWithDevice:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithDevice:">&ndash;&nbsp;initWithDevice:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Standard init with default properties per filter type</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nonnull instancetype)initWithDevice:(nonnull id&lt;MTLDevice&gt;)<em>device</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>device</code></th>
						<td><p>The <a href="../Classes/MPSKernel.html#//api/name/device">device</a> that the filter will be used on. May not be NULL.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>a pointer to the newly initialized object. This will fail, returning
nil if the <a href="../Classes/MPSKernel.html#//api/name/device">device</a> is not supported. Devices must be
MTLFeatureSet_iOS_GPUFamily2_v1 or later.</p>
			</div>
			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSKernel.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:" title="encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:"></a>
	<h3 class="method-title"><code><a href="#//api/name/encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:">&ndash;&nbsp;encodeSequenceToCommandBuffer:sourceMatrices:destinationMatrices:recurrentInputState:recurrentOutputStates:MPS_SWIFT_NAME:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Encode an MPSRNNMatrixInferenceLayer kernel (stack) for a sequence of inputs into a command buffer.
Note that when encoding using this function the @see layerSequenceDirection is ignored and the layer stack operates as
if all layers were forward feeding layers. In order to run bidirectional sequences
use @ref encodeBidirectionalSequenceToCommandBuffer:sourceSequence: or alternatively run two layer stacks and combine
results at the end using utility functions.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)encodeSequenceToCommandBuffer:(nonnull id&lt;MTLCommandBuffer&gt;)<em>commandBuffer</em> sourceMatrices:(NSArray&lt;MPSMatrix*&gt; *__nonnull)<em>sourceMatrices</em> destinationMatrices:(NSArray&lt;MPSMatrix*&gt; *__nonnull)<em>destinationMatrices</em> recurrentInputState:(MPSRNNRecurrentMatrixState *__nullable)<em>recurrentInputState</em> recurrentOutputStates:(NSMutableArray&lt;MPSRNNRecurrentMatrixState*&gt; *__nullable)<em>recurrentOutputStates</em> MPS_SWIFT_NAME</code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>commandBuffer</code></th>
						<td><p>A valid MTLCommandBuffer to receive the encoded filter</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>sourceMatrices</code></th>
						<td><p>An array of valid <a href="../Classes/MPSMatrix.html">MPSMatrix</a> objects containing the sequence of source matrices.</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>destinationMatrices</code></th>
						<td><p>An array valid MPSMatrices to be overwritten by result matrix sequence.
destinationMatrices may not alias sourceMatrices.</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>recurrentInputState</code></th>
						<td><p>An optional state containing the output matrices and memory cells (for LSTMs)
of the layer obtained from the previous input matrices in a sequence of inputs.
Has to be the output of a previous call to this function or nil (assumed zero).
Note: can be one of the states returned in @ref intermediateRecurrentStates.</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>recurrentOutputStates</code></th>
						<td><p>An optional array that will contain the recurrent output states. If nil then
the recurrent output state is discarded.
If @ref <a href="#//api/name/storeAllIntermediateStates">storeAllIntermediateStates</a> is YES, then all intermediate states of the sequence
are returned in the array, the first one corresponding to the first input in the sequence,
otherwise only the last recurrent output state is returned.
If <a href="#//api/name/recurrentOutputIsTemporary">recurrentOutputIsTemporary</a> is YES and then all returned recurrent states
will be temporary. @see <a href="../Classes/MPSState.html">MPSState</a>:isTemporary.
Example: In order to get a new state one can do the following:
<code>
MPSRNNRecurrentMatrixState* recurrent0 = nil;
[filter encodeToCommandBuffer: cmdBuf
sourceMatrix: source0
destinationMatrix: destination0
recurrentInputState: nil
recurrentOutputState: &amp;recurrent0];
</code>
Then use it for the next input in sequence:
<code>
[filter encodeToCommandBuffer: cmdBuf
sourceMatrix: source1
destinationMatrix: destination1
recurrentInputState: recurrent0
recurrentOutputState: &amp;recurrent0];
</code>
And discard recurrent output of the third input:
@code
[filter encodeToCommandBuffer: cmdBuf
sourceMatrix: source2
destinationMatrix: destination2
recurrentInputState: recurrent0
recurrentOutputState: nil];
@endcode</p></td>
					</tr>
				
				</table>
			</div>
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:" title="encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:"></a>
	<h3 class="method-title"><code><a href="#//api/name/encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:">&ndash;&nbsp;encodeBidirectionalSequenceToCommandBuffer:sourceSequence:destinationForwardMatrices:destinationBackwardMatrices:MPS_SWIFT_NAME:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Encode an MPSRNNMatrixInferenceLayer kernel stack for an input matrix sequences into a command buffer bidirectionally.
The operation proceeds as follows: The first source matrix x0 is passed through all forward traversing layers in the stack,
ie. those that were initialized with MPSRNNSequenceDirectionForward, recurrent input is assumed zero.
This produces forward output yf0 and recurrent states hf00, hf01, hf02, &hellip; hf0n, one for each forward layer in the stack.
Then x1 is passed to forward layers together with recurrent state hf00, hf01, &hellip;, hf0n, which produces yf1, and hf10,&hellip;
This procedure is iterated until the last matrix in the input sequence x<em>(N-1), which produces forward output yf(N-1).
The backwards layers iterate the same sequence backwards, starting from input x</em>(N-1) (recurrent state zero),
that produces yb(N-1) and recurrent output hb(N-1)0, hf(N-1)1, &hellip; hb(N-1)m, one for each backwards traversing layer.
Then the backwards layers handle input x_(N-2) using recurrent state hb(N-1)0, &hellip;, et cetera, until the
first matrix of the sequence is computed, producing output yb0. The result of the operation is either pair of sequences
({yf0, yf1, &hellip; , yf(N-1)},  {yb0, yb1, &hellip; , yb(N-1)}) or a combined sequence, {(yf0 + yb0), &hellip; , (yf(N-1) + yb(N-1)) },
where &lsquo;+&rsquo; stands either for sum, or concatenation along feature channels, as specified by @ref <a href="#//api/name/bidirectionalCombineMode">bidirectionalCombineMode</a>.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)encodeBidirectionalSequenceToCommandBuffer:(nonnull id&lt;MTLCommandBuffer&gt;)<em>commandBuffer</em> sourceSequence:(NSArray&lt;MPSMatrix*&gt; *__nonnull)<em>sourceSequence</em> destinationForwardMatrices:(NSArray&lt;MPSMatrix*&gt; *__nonnull)<em>destinationForwardMatrices</em> destinationBackwardMatrices:(NSArray&lt;MPSMatrix*&gt; *__nullable)<em>destinationBackwardMatrices</em> MPS_SWIFT_NAME</code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>commandBuffer</code></th>
						<td><p>A valid MTLCommandBuffer to receive the encoded filter</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>sourceSequence</code></th>
						<td><p>An array of valid <a href="../Classes/MPSMatrix.html">MPSMatrix</a> objects containing the source matrix sequence (x0, x1, &hellip; x_n-1).</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>destinationForwardMatrices</code></th>
						<td><p>An array of valid MPSMatrices to be overwritten by result from forward input matrices. If <a href="#//api/name/bidirectionalCombineMode">bidirectionalCombineMode</a>
is either MPSRNNBidirectionalCombineModeAdd or MPSRNNBidirectionalCombineModeConcatenate, then will
contain the combined results. destinationForwardMatrix may not alias with any of the source matrices.</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>destinationBackwardMatrices</code></th>
						<td><p>If <a href="#//api/name/bidirectionalCombineMode">bidirectionalCombineMode</a> is MPSRNNBidirectionalCombineModeNone, then must be an array of valid MPSMatrices
that will be overwritten by result from backward input matrices. Otherwise this parameter is ignored
and can be nil. destinationBackwardMatrices may not alias to any of the source matrices.</p></td>
					</tr>
				
				</table>
			</div>
			

			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithCoder:device:" title="initWithCoder:device:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithCoder:device:">&ndash;&nbsp;initWithCoder:device:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>NSSecureCoding compatability</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nullable instancetype)initWithCoder:(NSCoder *__nonnull)<em>aDecoder</em> device:(nonnull id&lt;MTLDevice&gt;)<em>device</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>aDecoder</code></th>
						<td><p>The NSCoder subclass with your serialized MPSRNNMatrixInferenceLayer</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>device</code></th>
						<td><p>The MTLDevice on which to make the MPSRNNMatrixInferenceLayer</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>A new MPSRNNMatrixInferenceLayer object, or nil if failure.</p>
			</div>
			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>See @ref MPSKernel#initWithCoder.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/copyWithZone:device:" title="copyWithZone:device:"></a>
	<h3 class="method-title"><code><a href="#//api/name/copyWithZone:device:">&ndash;&nbsp;copyWithZone:device:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>Make a copy of this kernel for a new device - @see <a href="../Classes/MPSKernel.html">MPSKernel</a></p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (nonnull instancetype)copyWithZone:(nullable NSZone *)<em>zone</em> device:(nullable id&lt;MTLDevice&gt;)<em>device</em></code></div>

		    
			
			<div class="method-subsection arguments-section parameters">
				<h4 class="method-subtitle parameter-title">Parameters</h4>
				<table class="argument-def parameter-def">
				
					<tr>
						<th scope="row" class="argument-name"><code>zone</code></th>
						<td><p>The NSZone in which to allocate the object</p></td>
					</tr>
				
					<tr>
						<th scope="row" class="argument-name"><code>device</code></th>
						<td><p>The device for the new <a href="../Classes/MPSKernel.html">MPSKernel</a>. If nil, then use
self.device.</p></td>
					</tr>
				
				</table>
			</div>
			

			
			<div class="method-subsection return">
				<h4 class="method-subtitle parameter-title">Return Value</h4>
				<p>a pointer to a copy of this <a href="../Classes/MPSKernel.html">MPSKernel</a>. This will fail, returning
nil if the device is not supported. Devices must be
MTLFeatureSet_iOS_GPUFamily2_v1 or later.</p>
			</div>
			

			

			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">MPSRNNLayer.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved. Updated: 2018-03-06</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>