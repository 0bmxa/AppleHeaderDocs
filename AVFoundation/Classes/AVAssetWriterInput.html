<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>AVAssetWriterInput Class Reference</title>

	<link rel="stylesheet" href="../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../index.html">MacOSX 10.13 AVFoundation Framework </a>
			</h1>

			<p id="developer-home">
				<a href="../index.html">Apple Inc.</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../index.html">Index</a></li>
<li><a href="../hierarchy.html">Hierarchy</a></li>

					<li id="on-this-page" role="navigation">
						<label>
							On This Page

							<div class="chevron">
								<div class="chevy chevron-left"></div>
								<div class="chevy chevron-right"></div>
							</div>

							<select id="jump-to">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	

	
	
	<option value="tasks">Tasks</option>
	
	

	
	
	<optgroup label="Properties">
		
		<option value="//api/name/_0">_0</option>
		
		<option value="//api/name/_7">_7</option>
		
		<option value="//api/name/_8">_8</option>
		
		<option value="//api/name/_9">_9</option>
		
		<option value="//api/name/expectsMediaDataInRealTime">expectsMediaDataInRealTime</option>
		
		<option value="//api/name/mediaType">mediaType</option>
		
		<option value="//api/name/metadata">metadata</option>
		
		<option value="//api/name/outputSettings">outputSettings</option>
		
		<option value="//api/name/readyForMoreMediaData">readyForMoreMediaData</option>
		
		<option value="//api/name/transform">transform</option>
		
	</optgroup>
	

	
	<optgroup label="Class Methods">
		
		<option value="//api/name/assetWriterInputWithMediaType:outputSettings:">+ assetWriterInputWithMediaType:outputSettings:</option>
		
		<option value="//api/name/assetWriterInputWithMediaType:outputSettings:sourceFormatHint:">+ assetWriterInputWithMediaType:outputSettings:sourceFormatHint:</option>
		
	</optgroup>
	

	
	<optgroup label="Instance Methods">
		
		<option value="//api/name/addTrackAssociationWithTrackOfInput:type:">- addTrackAssociationWithTrackOfInput:type:</option>
		
		<option value="//api/name/appendSampleBuffer:">- appendSampleBuffer:</option>
		
		<option value="//api/name/canAddTrackAssociationWithTrackOfInput:type:">- canAddTrackAssociationWithTrackOfInput:type:</option>
		
		<option value="//api/name/initWithMediaType:outputSettings:">- initWithMediaType:outputSettings:</option>
		
		<option value="//api/name/initWithMediaType:outputSettings:sourceFormatHint:">- initWithMediaType:outputSettings:sourceFormatHint:</option>
		
		<option value="//api/name/markAsFinished">- markAsFinished</option>
		
		<option value="//api/name/markCurrentPassAsFinished">- markCurrentPassAsFinished</option>
		
		<option value="//api/name/requestMediaDataWhenReadyOnQueue:usingBlock:">- requestMediaDataWhenReadyOnQueue:usingBlock:</option>
		
		<option value="//api/name/respondToEachPassDescriptionOnQueue:usingBlock:">- respondToEachPassDescriptionOnQueue:usingBlock:</option>
		
	</optgroup>
	
	
</select>
						</label>
					</li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview_contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">AVAssetWriterInput Class Reference</h1>

					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<th>Inherits from</th>
	<td>NSObject</td>
</tr><tr>
	<th>Declared in</th>
	<td>AVAssetWriterInput.h</td>
</tr>
						</tbody></table></div>
					

                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>@class AVAssetWriterInput
@abstract
    AVAssetWriterInput defines an interface for appending either new media samples or references to existing media samples packaged as CMSampleBuffer objects to a single track of the output file of an <a href="../Classes/AVAssetWriter.html">AVAssetWriter</a>.</p>

<p>@discussion
    Clients that need to write multiple concurrent tracks of media data should use one AVAssetWriterInput instance per track. In order to write multiple concurrent tracks with ideal interleaving of media data, clients should observe the value returned by the <a href="#//api/name/readyForMoreMediaData">readyForMoreMediaData</a> property of each AVAssetWriterInput instance.</p>

<pre><code>AVAssetWriterInput also supports writing per-track metadata collections to the output file.

As of OS X 10.10 and iOS 8.0 AVAssetWriterInput can also be used to create tracks that are not self-contained.  Such tracks reference sample data that is located in another file. This is currently supported only for instances of AVAssetWriterInput attached to an instance of AVAssetWriter that writes files of type AVFileTypeQuickTimeMovie.
</code></pre>
					</div>
					
					

					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						

						
						<h2 class="task-title">Other Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/assetWriterInputWithMediaType:outputSettings:" title="assetWriterInputWithMediaType:outputSettings:"></a>
	<h3 class="method-title"><code><a href="#//api/name/assetWriterInputWithMediaType:outputSettings:">+&nbsp;assetWriterInputWithMediaType:outputSettings:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method assetWriterInputWithMediaType:outputSettings:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (instancetype)assetWriterInputWithMediaType:(AVMediaType)<em>mediaType</em> outputSettings:(nullable NSDictionary&lt;NSString*,id&gt; *)<em>outputSettings</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method assetWriterInputWithMediaType:outputSettings:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>

<p>@param mediaType
    The media type of samples that will be accepted by the input. Media types are defined in AVMediaFormat.h.
@param outputSettings
    The settings used for encoding the media appended to the output.  See AVAudioSettings.h for AVMediaTypeAudio or AVVideoSettings.h for AVMediaTypeVideo and for more information on how to construct an output settings dictionary.  If you only require simple preset-based output settings, see AVOutputSettingsAssistant.
@result
    An instance of AVAssetWriterInput.</p>

<p>@discussion
    Each new input accepts data for a new track of the AVAssetWriter&rsquo;s output file.  Inputs are added to an asset writer using <a href="../Classes/AVAssetWriter.html#//api/name/addInput:">[AVAssetWriter addInput:]</a>.</p>

<pre><code>Passing nil for output settings instructs the input to pass through appended samples, doing no processing before they are written to the output file.  This is useful if, for example, you are appending buffers that are already in a desirable compressed format.  However, if not writing to a QuickTime Movie file (i.e. the AVAssetWriter was initialized with a file type other than AVFileTypeQuickTimeMovie), AVAssetWriter only supports passing through a restricted set of media types and subtypes.  In order to pass through media data to files other than AVFileTypeQuickTimeMovie, a non-NULL format hint must be provided using assetWriterInputWithMediaType:outputSettings:sourceFormatHint: instead of this method.

For AVMediaTypeAudio the following keys are not currently supported in the outputSettings dictionary: AVEncoderAudioQualityKey and AVSampleRateConverterAudioQualityKey.  When using this method to construct a new instance, an audio settings dictionary must be fully specified, meaning that it must contain AVFormatIDKey, AVSampleRateKey, and AVNumberOfChannelsKey.  If no other channel layout information is available, a value of 1 for AVNumberOfChannelsKey will result in mono output and a value of 2 will result in stereo output.  If AVNumberOfChannelsKey specifies a channel count greater than 2, the dictionary must also specify a value for AVChannelLayoutKey.  For kAudioFormatLinearPCM, all relevant AVLinearPCM*Key keys must be included, and for kAudioFormatAppleLossless, AVEncoderBitDepthHintKey keys must be included.  See assetWriterInputWithMediaType:outputSettings:sourceFormatHint: for a way to avoid having to specify a value for each of those keys.

For AVMediaTypeVideo, any output settings dictionary must request a compressed video format.  This means that the value passed in for outputSettings must follow the rules for compressed video output, as laid out in AVVideoSettings.h.  When using this method to construct a new instance, a video settings dictionary must be fully specified, meaning that it must contain AVVideoCodecKey, AVVideoWidthKey, and AVVideoHeightKey.  See assetWriterInputWithMediaType:outputSettings:sourceFormatHint: for a way to avoid having to specify a value for each of those keys.  On iOS, the only values currently supported for AVVideoCodecKey are AVVideoCodecTypeH264 and AVVideoCodecTypeJPEG.  AVVideoCodecTypeH264 is not supported on iPhone 3G.  For AVVideoScalingModeKey, the value AVVideoScalingModeFit is not supported.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/assetWriterInputWithMediaType:outputSettings:sourceFormatHint:" title="assetWriterInputWithMediaType:outputSettings:sourceFormatHint:"></a>
	<h3 class="method-title"><code><a href="#//api/name/assetWriterInputWithMediaType:outputSettings:sourceFormatHint:">+&nbsp;assetWriterInputWithMediaType:outputSettings:sourceFormatHint:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method assetWriterInputWithMediaType:outputSettings:sourceFormatHint:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>+ (instancetype)assetWriterInputWithMediaType:(AVMediaType)<em>mediaType</em> outputSettings:(nullable NSDictionary&lt;NSString*,id&gt; *)<em>outputSettings</em> sourceFormatHint:(nullable CMFormatDescriptionRef)<em>sourceFormatHint</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method assetWriterInputWithMediaType:outputSettings:sourceFormatHint:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>

<p>@param <a href="#//api/name/mediaType">mediaType</a>
    The media type of samples that will be accepted by the input. Media types are defined in AVMediaFormat.h.
@param <a href="#//api/name/outputSettings">outputSettings</a>
    The settings used for encoding the media appended to the output.  See AVAudioSettings.h for AVMediaTypeAudio or AVVideoSettings.h for AVMediaTypeVideo and for more information on how to construct an output settings dictionary.  If you only require simple preset-based output settings, see <a href="../Classes/AVOutputSettingsAssistant.html">AVOutputSettingsAssistant</a>.
@param sourceFormatHint
    A hint about the format of media data that will be appended to the new input.
@result
    An instance of AVAssetWriterInput.</p>

<p>@discussion
    A version of <a href="#//api/name/assetWriterInputWithMediaType:outputSettings:">assetWriterInputWithMediaType:outputSettings:</a> that includes the ability to hint at the format of media data that will be appended to the new instance of AVAssetWriterInput.  When a source format hint is provided, the <a href="#//api/name/outputSettings">outputSettings</a> dictionary is not required to be fully specified.  For AVMediaTypeAudio, this means that AVFormatIDKey is the only required key.  For AVMediaTypeVideo, this means that AVVideoCodecKey is the only required key.  Values for the remaining keys will be chosen by the asset writer input, with consideration given to the attributes of the source format.  To guarantee successful file writing, clients who specify a format hint should ensure that subsequently-appended buffers are of the specified format.</p>

<pre><code>An NSInvalidArgumentException will be thrown if the media type of the format description does not match the media type string passed into this method.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithMediaType:outputSettings:" title="initWithMediaType:outputSettings:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithMediaType:outputSettings:">&ndash;&nbsp;initWithMediaType:outputSettings:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method initWithMediaType:outputSettings:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (instancetype)initWithMediaType:(AVMediaType)<em>mediaType</em> outputSettings:(nullable NSDictionary&lt;NSString*,id&gt; *)<em>outputSettings</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method initWithMediaType:outputSettings:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.</p>

<p>@param mediaType
    The media type of samples that will be accepted by the input. Media types are defined in AVMediaFormat.h.
@param outputSettings
    The settings used for encoding the media appended to the output.  See AVAudioSettings.h for AVMediaTypeAudio or AVVideoSettings.h for AVMediaTypeVideo and for more information on how to construct an output settings dictionary.  If you only require simple preset-based output settings, see AVOutputSettingsAssistant.
@result
    An instance of AVAssetWriterInput.</p>

<p>@discussion
    Each new input accepts data for a new track of the AVAssetWriter&rsquo;s output file.  Inputs are added to an asset writer using <a href="../Classes/AVAssetWriter.html#//api/name/addInput:">[AVAssetWriter addInput:]</a>.</p>

<pre><code>Passing nil for output settings instructs the input to pass through appended samples, doing no processing before they are written to the output file.  This is useful if, for example, you are appending buffers that are already in a desirable compressed format.  However, if not writing to a QuickTime Movie file (i.e. the AVAssetWriter was initialized with a file type other than AVFileTypeQuickTimeMovie), AVAssetWriter only supports passing through a restricted set of media types and subtypes.  In order to pass through media data to files other than AVFileTypeQuickTimeMovie, a non-NULL format hint must be provided using initWithMediaType:outputSettings:sourceFormatHint: instead of this method.

For AVMediaTypeAudio the following keys are not currently supported in the outputSettings dictionary: AVEncoderAudioQualityKey and AVSampleRateConverterAudioQualityKey.  When using this initializer, an audio settings dictionary must be fully specified, meaning that it must contain AVFormatIDKey, AVSampleRateKey, and AVNumberOfChannelsKey.  If no other channel layout information is available, a value of 1 for AVNumberOfChannelsKey will result in mono output and a value of 2 will result in stereo output.  If AVNumberOfChannelsKey specifies a channel count greater than 2, the dictionary must also specify a value for AVChannelLayoutKey.  For kAudioFormatLinearPCM, all relevant AVLinearPCM*Key keys must be included, and for kAudioFormatAppleLossless, AVEncoderBitDepthHintKey keys must be included.  See initWithMediaType:outputSettings:sourceFormatHint: for a way to avoid having to specify a value for each of those keys.

For AVMediaTypeVideo, any output settings dictionary must request a compressed video format.  This means that the value passed in for outputSettings must follow the rules for compressed video output, as laid out in AVVideoSettings.h.  When using this initializer, a video settings dictionary must be fully specified, meaning that it must contain AVVideoCodecKey, AVVideoWidthKey, and AVVideoHeightKey.  See initWithMediaType:outputSettings:sourceFormatHint: for a way to avoid having to specify a value for each of those keys.  On iOS, the only values currently supported for AVVideoCodecKey are AVVideoCodecTypeH264 and AVVideoCodecTypeJPEG.  AVVideoCodecTypeH264 is not supported on iPhone 3G.  For AVVideoScalingModeKey, the value AVVideoScalingModeFit is not supported.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/initWithMediaType:outputSettings:sourceFormatHint:" title="initWithMediaType:outputSettings:sourceFormatHint:"></a>
	<h3 class="method-title"><code><a href="#//api/name/initWithMediaType:outputSettings:sourceFormatHint:">&ndash;&nbsp;initWithMediaType:outputSettings:sourceFormatHint:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method initWithMediaType:outputSettings:sourceFormatHint:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.  This is the designated initializer of AVAssetWriterInput.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (instancetype)initWithMediaType:(AVMediaType)<em>mediaType</em> outputSettings:(nullable NSDictionary&lt;NSString*,id&gt; *)<em>outputSettings</em> sourceFormatHint:(nullable CMFormatDescriptionRef)<em>sourceFormatHint</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method initWithMediaType:outputSettings:sourceFormatHint:
@abstract
    Creates a new input of the specified media type to receive sample buffers for writing to the output file.  This is the designated initializer of AVAssetWriterInput.</p>

<p>@param <a href="#//api/name/mediaType">mediaType</a>
    The media type of samples that will be accepted by the input. Media types are defined in AVMediaFormat.h.
@param <a href="#//api/name/outputSettings">outputSettings</a>
    The settings used for encoding the media appended to the output.  See AVAudioSettings.h for AVMediaTypeAudio or AVVideoSettings.h for AVMediaTypeVideo and for more information on how to construct an output settings dictionary.  If you only require simple preset-based output settings, see <a href="../Classes/AVOutputSettingsAssistant.html">AVOutputSettingsAssistant</a>.
@param sourceFormatHint
    A hint about the format of media data that will be appended to the new input.
@result
    An instance of AVAssetWriterInput.</p>

<p>@discussion
    A version of <a href="#//api/name/initWithMediaType:outputSettings:">initWithMediaType:outputSettings:</a> that includes the ability to hint at the format of media data that will be appended to the new instance of AVAssetWriterInput.  When a source format hint is provided, the <a href="#//api/name/outputSettings">outputSettings</a> dictionary is not required to be fully specified.  For AVMediaTypeAudio, this means that AVFormatIDKey is the only required key.  For AVMediaTypeVideo, this means that AVVideoCodecKey is the only required key.  Values for the remaining keys will be chosen by the asset writer input, with consideration given to the attributes of the source format.  To guarantee successful file writing, clients who specify a format hint should ensure that subsequently-appended buffers are of the specified format.</p>

<pre><code>An NSInvalidArgumentException will be thrown if the media type of the format description does not match the media type string passed into this method.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/mediaType" title="mediaType"></a>
	<h3 class="method-title"><code><a href="#//api/name/mediaType">&nbsp;&nbsp;mediaType</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property mediaType
@abstract
    The media type of the samples that can be appended to the receiver.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic, readonly) AVMediaType mediaType</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property mediaType
@abstract
    The media type of the samples that can be appended to the receiver.</p>

<p>@discussion
    The value of this property is one of the media type strings defined in AVMediaFormat.h.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/outputSettings" title="outputSettings"></a>
	<h3 class="method-title"><code><a href="#//api/name/outputSettings">&nbsp;&nbsp;outputSettings</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property outputSettings
@abstract
    The settings used for encoding the media appended to the output.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic, readonly, nullable) NSDictionary&lt;NSString*id&gt; *outputSettings</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property outputSettings
@abstract
    The settings used for encoding the media appended to the output.</p>

<p>@discussion
    The value of this property is an NSDictionary that contains values for keys as specified by either AVAudioSettings.h for AVMediaTypeAudio or AVVideoSettings.h for AVMediaTypeVideo.  A value of nil indicates that the receiver will pass through appended samples, doing no processing before they are written to the output file.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/_8" title="_8"></a>
	<h3 class="method-title"><code><a href="#//api/name/_8">&nbsp;&nbsp;_8</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property sourceFormatHint
@abstract
     The hint given at initialization time about the format of incoming media data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic, readonly, nullable) CMFormatDescriptionRef sourceFormatHint NS_AVAILABLE ( 10 _8</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property sourceFormatHint
@abstract
     The hint given at initialization time about the format of incoming media data.</p>

<p>@discussion
    AVAssetWriterInput may be able to use this hint to fill in missing output settings or perform more upfront validation.  To guarantee successful file writing, clients who specify a format hint should ensure that subsequently-appended media data are of the specified format.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/metadata" title="metadata"></a>
	<h3 class="method-title"><code><a href="#//api/name/metadata">&nbsp;&nbsp;metadata</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property metadata
@abstract
    A collection of metadata to be written to the track corresponding to the receiver.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic, copy) NSArray&lt;AVMetadataItem*&gt; *metadata</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property metadata
@abstract
    A collection of metadata to be written to the track corresponding to the receiver.</p>

<p>@discussion
    The value of this property is an array of <a href="../Classes/AVMetadataItem.html">AVMetadataItem</a> objects representing the collection of track-level metadata to be written in the output file.</p>

<pre><code>This property cannot be set after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/readyForMoreMediaData" title="readyForMoreMediaData"></a>
	<h3 class="method-title"><code><a href="#//api/name/readyForMoreMediaData">&nbsp;&nbsp;readyForMoreMediaData</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property readyForMoreMediaData
@abstract
    Indicates the readiness of the input to accept more media data.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic, readonly, getter=isReadyForMoreMediaData) BOOL readyForMoreMediaData</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property readyForMoreMediaData
@abstract
    Indicates the readiness of the input to accept more media data.</p>

<p>@discussion
    When there are multiple inputs, <a href="../Classes/AVAssetWriter.html">AVAssetWriter</a> tries to write media data in an ideal interleaving pattern for efficiency in storage and playback. Each of its inputs signals its readiness to receive media data for writing according to that pattern via the value of readyForMoreMediaData. You can append media data to an input only while its readyForMoreMediaData property is YES.</p>

<pre><code>Clients writing media data from a non-real-time source, such as an instance of AVAssetReader, should hold off on generating or obtaining more media data to append to an input when the value of readyForMoreMediaData is NO. To help with control of the supply of non-real-time media data, such clients can use -requestMediaDataWhenReadyOnQueue:usingBlock in order to specify a block that the input should invoke whenever it's ready for input to be appended.

Clients writing media data from a real-time source, such as an instance of AVCaptureOutput, should set the input's expectsMediaDataInRealTime property to YES to ensure that the value of readyForMoreMediaData is calculated appropriately. When expectsMediaDataInRealTime is YES, readyForMoreMediaData will become NO only when the input cannot process media samples as quickly as they are being provided by the client. If readyForMoreMediaData becomes NO for a real-time source, the client may need to drop samples or consider reducing the data rate of appended samples.

When the value of canPerformMultiplePasses is YES for any input attached to this input's asset writer, the value for this property may start as NO and/or be NO for long periods of time.

The value of readyForMoreMediaData will often change from NO to YES asynchronously, as previously supplied media data is processed and written to the output.  It is possible for all of an AVAssetWriter's AVAssetWriterInputs temporarily to return NO for readyForMoreMediaData.

This property is key value observable. Observers should not assume that they will be notified of changes on a specific thread.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/expectsMediaDataInRealTime" title="expectsMediaDataInRealTime"></a>
	<h3 class="method-title"><code><a href="#//api/name/expectsMediaDataInRealTime">&nbsp;&nbsp;expectsMediaDataInRealTime</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property expectsMediaDataInRealTime
@abstract
    Indicates whether the input should tailor its processing of media data for real-time sources.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic) BOOL expectsMediaDataInRealTime</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property expectsMediaDataInRealTime
@abstract
    Indicates whether the input should tailor its processing of media data for real-time sources.</p>

<p>@discussion
    Clients appending media data to an input from a real-time source, such as an <a href="../Classes/AVCaptureOutput.html">AVCaptureOutput</a>, should set expectsMediaDataInRealTime to YES. This will ensure that <a href="#//api/name/readyForMoreMediaData">readyForMoreMediaData</a> is calculated appropriately for real-time usage.</p>

<pre><code>For best results, do not set both this property and performsMultiPassEncodingIfSupported to YES.

This property cannot be set after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/requestMediaDataWhenReadyOnQueue:usingBlock:" title="requestMediaDataWhenReadyOnQueue:usingBlock:"></a>
	<h3 class="method-title"><code><a href="#//api/name/requestMediaDataWhenReadyOnQueue:usingBlock:">&ndash;&nbsp;requestMediaDataWhenReadyOnQueue:usingBlock:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method requestMediaDataWhenReadyOnQueue:usingBlock:
@abstract
    Instructs the receiver to invoke a client-supplied block repeatedly, at its convenience, in order to gather media data for writing to the output file.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)requestMediaDataWhenReadyOnQueue:(dispatch_queue_t)<em>queue</em> usingBlock:(void ( ^ ) ( void ))<em>block</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method requestMediaDataWhenReadyOnQueue:usingBlock:
@abstract
    Instructs the receiver to invoke a client-supplied block repeatedly, at its convenience, in order to gather media data for writing to the output file.</p>

<p>@param queue
    The queue on which the block should be invoked.
@param block
    The block the input should invoke to obtain media data.</p>

<p>@discussion
    The block should append media data to the input either until the input&rsquo;s readyForMoreMediaData property becomes NO or until there is no more media data to supply (at which point it may choose to mark the input as finished via -markAsFinished). The block should then exit. After the block exits, if the input has not been marked as finished, once the input has processed the media data it has received and becomes ready for more media data again, it will invoke the block again in order to obtain more.</p>

<pre><code>A typical use of this method, with a block that supplies media data to an input while respecting the input's readyForMoreMediaData property, might look like this:

[myAVAssetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^{
    while ([myAVAssetWriterInput isReadyForMoreMediaData])
    {
        CMSampleBufferRef nextSampleBuffer = [self copyNextSampleBufferToWrite];
        if (nextSampleBuffer)
        {
            [myAVAssetWriterInput appendSampleBuffer:nextSampleBuffer];
            CFRelease(nextSampleBuffer);
        }
        else
        {
            [myAVAssetWriterInput markAsFinished];
            break;
        }
    }
}];

This method is not recommended for use with a push-style buffer source, such as AVCaptureAudioDataOutput or AVCaptureVideoDataOutput, because such a combination will likely require intermediate queueing of buffers.  Instead, this method is better suited to a pull-style buffer source such as AVAssetReaderOutput, as illustrated in the above example.

When using a push-style buffer source, it is generally better to immediately append each buffer to the AVAssetWriterInput, directly via [AVAssetWriter appendSampleBuffer:], as it is received.  Using this strategy, it is often possible to avoid  having to queue up buffers in between the buffer source and the AVAssetWriterInput.  Note that many of these push-style buffer sources also produce buffers in real-time, in which case the client should set expectsMediaDataInRealTime to YES.

Before calling this method, you must ensure that the receiver is attached to an AVAssetWriter via a prior call to -addInput: and that -startWriting has been called on the asset writer.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/appendSampleBuffer:" title="appendSampleBuffer:"></a>
	<h3 class="method-title"><code><a href="#//api/name/appendSampleBuffer:">&ndash;&nbsp;appendSampleBuffer:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method appendSampleBuffer:
@abstract
    Appends samples to the receiver.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)appendSampleBuffer:(CMSampleBufferRef)<em>sampleBuffer</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method appendSampleBuffer:
@abstract
    Appends samples to the receiver.</p>

<p>@param sampleBuffer
    The CMSampleBuffer to be appended.
@result
    A BOOL value indicating success of appending the sample buffer. If a result of NO is returned, clients can check the value of AVAssetWriter.status to determine whether the writing operation completed, failed, or was cancelled.  If the status is AVAssetWriterStatusFailed, AVAsset.error will contain an instance of NSError that describes the failure.</p>

<p>@discussion
    The timing information in the sample buffer, considered relative to the time passed to <a href="../Classes/AVAssetWriter.html#//api/name/startSessionAtSourceTime:">[AVAssetWriter startSessionAtSourceTime:]</a>, will be used to determine the timing of those samples in the output file.</p>

<pre><code>For track types other than audio tracks, to determine the duration of all samples in the output file other than the very last sample that's appended, the difference between the sample buffer's output DTS and the following sample buffer's output DTS will be used. The duration of the last sample is determined as follows:
1. If a marker sample buffer with kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration is appended following the last media-bearing sample, the difference between the output DTS of the marker sample buffer and the output DTS of the last media-bearing sample will be used.
2. If the marker sample buffer is not provided and if the output duration of the last media-bearing sample is valid, it will be used.
3. if the output duration of the last media-bearing sample is not valid, the duration of the second-to-last sample will be used.

For audio tracks, the properties of each appended sample buffer are used to determine corresponding output durations.

The receiver will retain the CMSampleBuffer until it is done with it, and then release it.  Do not modify a CMSampleBuffer or its contents after you have passed it to this method.

If the sample buffer contains audio data and the AVAssetWriterInput was intialized with an outputSettings dictionary then the format must be linear PCM. If the outputSettings dictionary was nil then audio data can be provided in a compressed format, and it will be passed through to the output without any re-compression. Note that advanced formats like AAC will have encoder delay present in their bitstreams. This data is inserted by the encoder and is necessary for proper decoding, but it is not meant to be played back. Clients who provide compressed audio bitstreams must use kCMSampleBufferAttachmentKey_TrimDurationAtStart to mark the encoder delay (generally restricted to the first sample buffer). Packetization can cause there to be extra audio frames in the last packet which are not meant to be played back. These remainder frames should be marked with kCMSampleBufferAttachmentKey_TrimDurationAtEnd. CMSampleBuffers obtained from AVAssetReader will already have the necessary trim attachments. Please see http://developer.apple.com/mac/library/technotes/tn2009/tn2258.html for more information about encoder delay. When attaching trims make sure that the output PTS of the sample buffer is what you expect. For example if you called [AVAssetWriter startSessionAtSourceTime:kCMTimeZero] and you want your audio to start at time zero in the output file then make sure that the output PTS of the first non-fully trimmed audio sample buffer is kCMTimeZero.

If the sample buffer contains a CVPixelBuffer then the choice of pixel format will affect the performance and quality of the encode. For optimal performance the format of the pixel buffer should match one of the native formats supported by the selected video encoder. Below are some recommendations:

The H.264 encoder natively supports kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange and kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, which should be used with video and full range input respectively. The JPEG encoder on iOS natively supports kCVPixelFormatType_422YpCbCr8FullRange. For other video codecs on OSX, kCVPixelFormatType_422YpCbCr8 is the preferred pixel format for video and is generally the most performant when encoding. If you need to work in the RGB domain then kCVPixelFormatType_32BGRA is recommended on iOS and kCVPixelFormatType_32ARGB is recommended on OSX.

Pixel buffers not in a natively supported format will be converted internally prior to encoding when possible. Pixel format conversions within the same range (video or full) are generally faster than conversions between different ranges.

The ProRes encoders can preserve high bit depth sources, supporting up to 12bits/ch. ProRes 4444 can contain a mathematically lossless alpha channel and it doesn't do any chroma subsampling. This makes ProRes 4444 ideal for quality critical applications. If you are working with 8bit sources ProRes is also a good format to use due to its high image quality. Use either of the recommended pixel formats above. Note that RGB pixel formats by definition have 4:4:4 chroma sampling.

If you are working with high bit depth sources the following yuv pixel formats are recommended when encoding to ProRes: kCVPixelFormatType_4444AYpCbCr16, kCVPixelFormatType_422YpCbCr16, and kCVPixelFormatType_422YpCbCr10. When working in the RGB domain kCVPixelFormatType_64ARGB is recommended. Scaling and color matching are not currently supported when using AVAssetWriter with any of these high bit depth pixel formats. Please make sure that your track's output settings dictionary specifies the same width and height as the buffers you will be appending. Do not include AVVideoScalingModeKey or AVVideoColorPropertiesKey.

As of OS X 10.10 and iOS 8.0, this method can be used to add sample buffers that reference existing data in a file instead of containing media data to be appended to the file. This can be used to generate tracks that are not self-contained. In order to append such a sample reference to the track create a CMSampleBufferRef with a NULL dataBuffer and dataReady set to true and set the kCMSampleBufferAttachmentKey_SampleReferenceURL and kCMSampleBufferAttachmentKey_SampleReferenceByteOffset attachments on the sample buffer. Further documentation on how to create such a "sample reference" sample buffer can be found in the description of the kCMSampleBufferAttachmentKey_SampleReferenceURL and kCMSampleBufferAttachmentKey_SampleReferenceByteOffset attachment keys in the CMSampleBuffer documentation.

Before calling this method, you must ensure that the receiver is attached to an AVAssetWriter via a prior call to -addInput: and that -startWriting has been called on the asset writer.  It is an error to invoke this method before starting a session (via [AVAssetWriter startSessionAtSourceTime:]) or after ending a session (via [AVAssetWriter endSessionAtSourceTime:]).
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/markAsFinished" title="markAsFinished"></a>
	<h3 class="method-title"><code><a href="#//api/name/markAsFinished">&ndash;&nbsp;markAsFinished</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method markAsFinished
@abstract
    Indicates to the <a href="../Classes/AVAssetWriter.html">AVAssetWriter</a> that no more buffers will be appended to this input.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)markAsFinished</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method markAsFinished
@abstract
    Indicates to the <a href="../Classes/AVAssetWriter.html">AVAssetWriter</a> that no more buffers will be appended to this input.</p>

<p>@discussion
    Clients that are monitoring each input&rsquo;s <a href="#//api/name/readyForMoreMediaData">readyForMoreMediaData</a> value must call markAsFinished on an input when they are done appending buffers to it.  This is necessary to prevent other inputs from stalling, as they may otherwise wait forever for that input&rsquo;s media data, attempting to complete the ideal interleaving pattern.</p>

<pre><code>After invoking this method from the serial queue passed to requestMediaDataWhenReadyOnQueue:usingBlock:, the receiver is guaranteed to issue no more invocations of the block passed to that method.  The same is true of respondToEachPassDescriptionOnQueue:usingBlock:.

Before calling this method, you must ensure that the receiver is attached to an AVAssetWriter via a prior call to -addInput: and that -startWriting has been called on the asset writer.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="AVAssetWriterInputTrackAssociations Methods" name="task_AVAssetWriterInputTrackAssociations Methods"></a>
						<h2 class="task-title">AVAssetWriterInputTrackAssociations Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/canAddTrackAssociationWithTrackOfInput:type:" title="canAddTrackAssociationWithTrackOfInput:type:"></a>
	<h3 class="method-title"><code><a href="#//api/name/canAddTrackAssociationWithTrackOfInput:type:">&ndash;&nbsp;canAddTrackAssociationWithTrackOfInput:type:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method canAddTrackAssociationWithTrackOfInput:type:
@abstract
    Tests whether an association between the tracks corresponding to a pair of inputs is valid.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (BOOL)canAddTrackAssociationWithTrackOfInput:(AVAssetWriterInput *)<em>input</em> type:(NSString *)<em>trackAssociationType</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method canAddTrackAssociationWithTrackOfInput:type:
@abstract
    Tests whether an association between the tracks corresponding to a pair of inputs is valid.</p>

<p>@param input
    The instance of AVAssetWriterInput with a corresponding track to associate with track corresponding with the receiver.
@param trackAssociationType
    The type of track association to test. Common track association types, such as AVTrackAssociationTypeTimecode, are defined in <a href="../Classes/AVAssetTrack.html">AVAssetTrack</a>.h.</p>

<p>@discussion
    If the type of association requires tracks of specific media types that don&rsquo;t match the media types of the inputs, or if the output file type does not support track associations, -canAddTrackAssociationWithTrackOfInput:type: will return NO.</p>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/addTrackAssociationWithTrackOfInput:type:" title="addTrackAssociationWithTrackOfInput:type:"></a>
	<h3 class="method-title"><code><a href="#//api/name/addTrackAssociationWithTrackOfInput:type:">&ndash;&nbsp;addTrackAssociationWithTrackOfInput:type:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method addTrackAssociationWithTrackOfInput:type:
@abstract
    Associates the track corresponding to the specified input with the track corresponding with the receiver.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)addTrackAssociationWithTrackOfInput:(AVAssetWriterInput *)<em>input</em> type:(NSString *)<em>trackAssociationType</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method addTrackAssociationWithTrackOfInput:type:
@abstract
    Associates the track corresponding to the specified input with the track corresponding with the receiver.</p>

<p>@param input
    The instance of AVAssetWriterInput with a corresponding track to associate with track corresponding to the receiver.
@param trackAssociationType
    The type of track association to add. Common track association types, such as AVTrackAssociationTypeTimecode, are defined in <a href="../Classes/AVAssetTrack.html">AVAssetTrack</a>.h.</p>

<p>@discussion
    If the type of association requires tracks of specific media types that don&rsquo;t match the media types of the inputs, or if the output file type does not support track associations, an NSInvalidArgumentException is raised.</p>

<pre><code>Track associations cannot be added after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="AVAssetWriterInputMultiPass Methods" name="task_AVAssetWriterInputMultiPass Methods"></a>
						<h2 class="task-title">AVAssetWriterInputMultiPass Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/_0" title="_0"></a>
	<h3 class="method-title"><code><a href="#//api/name/_0">&nbsp;&nbsp;_0</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property performsMultiPassEncodingIfSupported
@abstract
    Indicates whether the input should attempt to encode the source media data using multiple passes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic) BOOL performsMultiPassEncodingIfSupported NS_AVAILABLE ( 10 _10 , 8 _0</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property performsMultiPassEncodingIfSupported
@abstract
    Indicates whether the input should attempt to encode the source media data using multiple passes.</p>

<p>@discussion
    The input may be able to achieve higher quality and/or lower data rate by performing multiple passes over the source media.  It does this by analyzing the media data that has been appended and re-encoding certain segments with different parameters.  In order to do this re-encoding, the media data for these segments must be appended again.  See -markCurrentPassAsFinished and the property currentPassDescription for the mechanism by which the input nominates segments for re-appending.</p>

<pre><code>When the value of this property is YES, the value of readyForMoreMediaData for other inputs attached to the same AVAssetWriter may be NO more often and/or for longer periods of time.  In particular, the value of readyForMoreMediaData for inputs that do not (or cannot) perform multiple passes may start out as NO after [AVAssetWriter startWriting] has been called and may not change to YES until after all multi-pass inputs have completed their final pass.

When the value of this property is YES, the input may store data in one or more temporary files before writing compressed samples to the output file.  Use the AVAssetWriter property directoryForTemporaryFiles if you need to control the location of temporary file writing.

The default value is NO, meaning that no additional analysis will occur and no segments will be re-encoded.  Not all asset writer input configurations (for example, inputs configured with certain media types or to use certain encoders) can benefit from performing multiple passes over the source media.  To determine whether the selected encoder can perform multiple passes, query the value of canPerformMultiplePasses after calling -startWriting.

For best results, do not set both this property and expectsMediaDataInRealTime to YES.

This property cannot be set after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/respondToEachPassDescriptionOnQueue:usingBlock:" title="respondToEachPassDescriptionOnQueue:usingBlock:"></a>
	<h3 class="method-title"><code><a href="#//api/name/respondToEachPassDescriptionOnQueue:usingBlock:">&ndash;&nbsp;respondToEachPassDescriptionOnQueue:usingBlock:</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method respondToEachPassDescriptionOnQueue:usingBlock:
@abstract
    Instructs the receiver to invoke a client-supplied block whenever a new pass has begun.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)respondToEachPassDescriptionOnQueue:(dispatch_queue_t)<em>queue</em> usingBlock:(dispatch_block_t)<em>block</em></code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method respondToEachPassDescriptionOnQueue:usingBlock:
@abstract
    Instructs the receiver to invoke a client-supplied block whenever a new pass has begun.</p>

<p>@param queue
    The queue on which the block should be invoked.
@param block
    A block the receiver should invoke whenever a new pass has begun.</p>

<p>@discussion
    A typical block passed to this method will perform the following steps:</p>

<pre><code>    1. Query the value of the receiver's currentPassDescription property and reconfigure the source of media data (e.g. AVAssetReader) accordingly
    2. Call requestMediaDataWhenReadyOnQueue:usingBlock: to begin appending data for the current pass
    3. Exit

When all media data has been appended for the current request, call markCurrentPassAsFinished to begin the process of determining whether an additional pass is warranted.  If an additional pass is warranted, the block passed to this method will be invoked to begin the next pass.  If no additional passes are needed, the block passed to this method will be invoked one final time so the client can invoke markAsFinished in response to the value of currentPassDescription becoming nil.

Before calling this method, you must ensure that the receiver is attached to an AVAssetWriter via a prior call to -addInput: and that -startWriting has been called on the asset writer.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div><div class="section-method">
	<a name="//api/name/markCurrentPassAsFinished" title="markCurrentPassAsFinished"></a>
	<h3 class="method-title"><code><a href="#//api/name/markCurrentPassAsFinished">&ndash;&nbsp;markCurrentPassAsFinished</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@method markCurrentPassAsFinished
@abstract
    Instructs the receiver to analyze the media data that has been appended and determine whether the results could be improved by re-encoding certain segments.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>- (void)markCurrentPassAsFinished</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@method markCurrentPassAsFinished
@abstract
    Instructs the receiver to analyze the media data that has been appended and determine whether the results could be improved by re-encoding certain segments.</p>

<p>@discussion
    When the value of canPerformMultiplePasses is YES, call this method after you have appended all of your media data.  After the receiver analyzes whether an additional pass is warranted, the value of currentPassDescription will change (usually asynchronously) to describe how to set up for the next pass.  Although it is possible to use key-value observing to determine when the value of currentPassDescription has changed, it is typically more convenient to invoke <a href="#//api/name/respondToEachPassDescriptionOnQueue:usingBlock:">respondToEachPassDescriptionOnQueue:usingBlock:</a> in order to start the work for each pass.</p>

<pre><code>After re-appending the media data for all of the time ranges of the new pass, call this method again to determine whether additional segments should be re-appended in another pass.

Calling this method effectively cancels any previous invocation of requestMediaDataWhenReadyOnQueue:usingBlock:, meaning that requestMediaDataWhenReadyOnQueue:usingBlock: can be invoked again for each new pass.  respondToEachPassDescriptionOnQueue:usingBlock: provides a convenient way to consolidate these invocations in your code.

After each pass, you have the option of keeping the most recent results by calling markAsFinished instead of this method.  If the value of currentPassDescription is nil at the beginning of a pass, call markAsFinished to tell the receiver to not expect any further media data.

If the value of canPerformMultiplePasses is NO, the value of currentPassDescription will immediately become nil after calling this method.

Before calling this method, you must ensure that the receiver is attached to an AVAssetWriter via a prior call to -addInput: and that -startWriting has been called on the asset writer.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="AVAssetWriterInputPropertiesForAudibleCharacteristic Methods" name="task_AVAssetWriterInputPropertiesForAudibleCharacteristic Methods"></a>
						<h2 class="task-title">AVAssetWriterInputPropertiesForAudibleCharacteristic Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/_9" title="_9"></a>
	<h3 class="method-title"><code><a href="#//api/name/_9">&nbsp;&nbsp;_9</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property preferredVolume
@abstract
    The preferred volume level to be stored in the output file.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic) float preferredVolume NS_AVAILABLE ( 10 _9</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property preferredVolume
@abstract
    The preferred volume level to be stored in the output file.</p>

<p>@discussion
    The value for this property should typically be in the range of 0.0 to 1.0.  The default value is 1.0, which is equivalent to a &ldquo;normal&rdquo; volume level for audio media type. For all other media types the default value is 0.0.</p>

<pre><code>This property cannot be set after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="AVAssetWriterInputFileTypeSpecificProperties Methods" name="task_AVAssetWriterInputFileTypeSpecificProperties Methods"></a>
						<h2 class="task-title">AVAssetWriterInputFileTypeSpecificProperties Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/_7" title="_7"></a>
	<h3 class="method-title"><code><a href="#//api/name/_7">&nbsp;&nbsp;_7</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property mediaTimeScale
@abstract
    For file types that support media time scales, such as QuickTime Movie files, specifies the media time scale to be used.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic) CMTimeScale mediaTimeScale NS_AVAILABLE ( 10 _7</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property mediaTimeScale
@abstract
    For file types that support media time scales, such as QuickTime Movie files, specifies the media time scale to be used.</p>

<p>@discussion
    The default value is 0, which indicates that the receiver should choose a convenient value, if applicable.  It is an error to set a value other than 0 if the receiver has media type AVMediaTypeAudio.</p>

<pre><code>This property cannot be set after writing has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						

						<a title="AVAssetWriterInputPropertiesForVisualCharacteristic Methods" name="task_AVAssetWriterInputPropertiesForVisualCharacteristic Methods"></a>
						<h2 class="task-title">AVAssetWriterInputPropertiesForVisualCharacteristic Methods</h2>

						<div class="task-list">
							<div class="section-method">
	<a name="//api/name/transform" title="transform"></a>
	<h3 class="method-title"><code><a href="#//api/name/transform">&nbsp;&nbsp;transform</a></code>
</h3>

	<div class="method-info">
		<div class="pointy-thing"></div>

		<div class="method-info-container">
			
			
			<div class="method-subsection brief-description">
				<p>@property transform
@abstract
    The transform specified in the output file as the preferred transformation of the visual media data for display purposes.</p>
			</div>
			
		    

			<div class="method-subsection method-declaration"><code>@property (nonatomic) CGAffineTransform transform</code></div>

		    
			

			

			

			
			<div class="method-subsection discussion-section">
				<h4 class="method-subtitle">Discussion</h4>
				<p>@property transform
@abstract
    The transform specified in the output file as the preferred transformation of the visual media data for display purposes.</p>

<p>@discussion
    If no value is specified, the identity transform is used.</p>

<pre><code>This property cannot be set after writing on the receiver's AVAssetWriter has started.
</code></pre>
			</div>
			

			

			

			
			<div class="method-subsection declared-in-section">
				<h4 class="method-subtitle">Declared In</h4>
				<p><code class="declared-in-ref">AVAssetWriterInput.h</code></p>
			</div>
			
			
		</div>
	</div>
</div>
						</div>
						
					</div>
					
					

                    
                    
          
				</main>

				<footer>
					<div class="footer-copyright">
						
						<p class="copyright">Copyright &copy; 2018 Apple Inc. All rights reserved. Updated: 2018-03-06</p>
						
						
						<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
						
					</div>
				</footer>
			</div>
		</div>
	</article>

	<script src="../js/script.js"></script>
</body>
</html>